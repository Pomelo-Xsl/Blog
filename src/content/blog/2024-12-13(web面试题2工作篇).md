---
title: 常见web面试题
description: 常见web面试题(工作篇2)
pubDate: 2024 12 13
categories:
- 工作
tags:
- 好资料

image: https://blog.wordup.com.tw/wp-content/uploads/2021/03/%E9%9F%93%E6%96%87%E6%95%B8%E5%AD%97.jpg 
---

# 0z 面试题

## 1.  HTML

### 1.1  Node 与 Element 的关系

Element继承自Node，具有Node的方法同时扩展了很多自己的方法

### 1.2 语义化的理解

使用语义化标签，如头部用header，主体用main，底部用footer

使用语义化能够让HTML结构更加清晰明了，方便团队协作，利于开发；有利于爬虫和SEO；能够让浏览器更好的去解析代码

### 1.3 H5新特性

1. 语义化的标签
2. 新增音频视频
3. 画布canvas
4. 数据存储localstorage和sessionstorage
5. 增加了表单控件email,url,search……
6. 拖拽释放API

### 1.4 H5移除的元素

basefont、big、center、font、s、strike、tt、u、frame、frameset、noframes

## 2.  CSS

### 2.1  css绘制三角形

```css
.box {
        width: 0;
        height: 0;
        border-width: 20px;
        border-style: solid;
        border-color: transparent transparent red transparent;
}
```

### 2.2  精灵图和base64的区别是什么？

精灵图：把多张小图整合到一张大图上，利用定位的一些属性把小图显示在页面上，当访问页面时可以减少请求，提高加载速度

base64：传输8Bit字节代码的编码方式，把原本二进制形式转为64个字符的单位，最后组成字符串

base64是会和html css一起下载到浏览器中，减少请求，减少跨域问题，但是一些低版本不支持，若base64体积比原图片大，不利于css的加载

### 2.3  VW和百分比的区别

百分比会继承父元素

vw是视口宽度，只和设备宽度有关

### 2.4  说一说CSS盒模型

在HTML中的所有元素都可以看成是一个盒子

盒子的组成：内容content、内边距padding、边框border、外边距margin

盒模型的类型：

- 标准盒模型：margin + border + padding + content
- IE盒模型：margin + content（border + padding）

控制盒模型的模式：box-sizing：content-box（默认值，标准盒模型）、border-box（IE盒模型）

### 2.5 CSS选择器的优先级

!important > 行内 > id > 类/伪类/元素 > 标签 > 通配符选择器

### 2.6 隐藏元素的方法有哪些

1. display:none;

   元素在页面上消失，不占据空间

2. opacity:0；

   设置了元素的透明度为0，元素不可见，占据空间位置

3. position:absolute;

4. clip-path

### 2.7 重排和重绘的区别

重排（回流）：布局引擎会根据所有的样式计算出盒模型在页面上的位置和大小，对DOM的大小、位置进行修改后，浏览器需要重新计算元素的这些几何属性，就叫重排

重绘：计算好盒模型的位置、大小和其他一些属性之后，浏览器会根据每个盒模型的特性进行绘制，对DOM的样式进行修改，比如color和background-color，浏览器不需要重新计算集合属性的时候，直接绘制了该元素的新样式，那么这里就只触发了重绘

### 2.8 让一个元素水平居中的方式有哪些

1. 定位 + margin
2. 定位 + transform
3. flex布局
4. grid布局
5. table布局

### 2.9 CSS3的新特性

1. 新增选择器：属性选择器、伪类选择器、伪元素选择器
2. 新增了媒体查询
3. 文字阴影
4. 边框
5. 盒子模型box-sizing
6. 渐变
7. 过渡
8. 自定义动画
9. 背景的属性
10. 2D和3D

## 3.  JS

### 3.1  var let const 的区别

var有声明提升并且会重复声明会被覆盖，没有块作用域

let不会进行声明提升且有块作用域

let和const的区别在于，const通常用于定义常量或对象和数组，用const声明的变量只能赋值一次，let用来声明变量后可以改变变量的值

### 3.2  判断一个变量是数组还是对象

```javascript
var a =[]
var obj = {
    toString:function(){
        return 'x'
    }
}
//Array.isArray()  存在兼容性问题
console.log(a instance of Array)   //true
console.log(a.constructor === Array)    //true
//以上弊端：会忽略iframe元素
//var iframe = document.createElement('iframe')
//document.body.append(iframe)
//var xArray = window.frames[window.frames.length -1].Array
//var arr = new xArray(1,2,3)

console.log(Object.prototype.toString.call(a)==='[object Array]')//用顶级原型上的toString方法，因为toString方法可以被重写    true
console.log(Object.prototype.toString.call(obj)==='[object Object]')    //true
```

### 3.3  JS数据类型有哪些，区别是什么

- 基本数据类型：Number、String、Boolean、BigInt（提供一种方法来表示比Number最大值更大的整数，可以表示任意大的整数）、Symbol（创建之后独一无二不可变）、Null、Undefined
- Object（包含普通object，函数，数组等）
- 区别：基本数据类型存储在栈中，占用空间小；而引用数据类型存储在堆中，占用空间大，引用类型的指针存储在栈中；

### 3.4 ES6的新特性有哪些

1. 新增块级作用域（let，const）
2. 新增了定义类的语法糖（class）
3. 新增了一种基本数据类型（symbol）
4. 新增了解构赋值
5. 新增了函数参数的默认值
6. 给数组新增了API
7. 对象和数组新增了扩展运算符
8. Promise
9. 新增了模块化（import，export）
10. 新增了set和map数据结构
11. 新增了generator
12. 新增了箭头函数



### 3.5  对闭包的理解

能访问到外部函数作用域中变量的函数，在需要隐藏一些不希望被别人访问的内容时就可以使用

构成闭包的条件：

1. 函数的嵌套
2. 内部函数要引用外部函数中的变量
3. 内部函数要作为返回值返回

```javascript
function outer(){
    let num = 0
    return ()= >{
        num++
    }
}
```

使用闭包的原因：

1. 避免变量被污染
2. 私有化
3. 保存变量，长驻内存

应用场景：防抖节流，库的封装（保证数据私有性）

### 3.6  JavaScript有几种方法判断变量的类型

- typeof：常用于判断基本数据类型，对于引用数据类型，除了function返回‘function’，其余全部返回‘object’
- instanceof：主要用于区分引用数据类型，检测方法是检测的类型在当前实例的原型链上，用其检测出来的结果都是true，不太适合用于简单数据类型的检测，检测过程繁琐且对于简单数据类型中的undefined，null，symbol检测不出来
- constructor：用于检测引用数据类型，检测方法是获取实例的构造函数判断和某个类是否相同，如果相同就说明该数据是符合那个数据类型的，这种方法不会把原型链上的其他类也加入进来，避免了原型链的干扰
- Object.prototype.toString.call()：适用于所有类型的判断检测，检测方法是Object.prototypel.toString.call(数据)返回的是该数据类型的字符串（原理：Object.prototypel.toString表示一个返回对象类型的字符串，call()方法可以改变this的指向，那么把Object.prototype.toString()方法指向不同的数据类型上面，返回不同的结果）

### 3.7  call apply bind的作用和区别

都可以改变函数内部的this指向

区别：

1. call 和 apply 会调用函数，并且改变函数内部this指向。
2. call 和 apply 传递的参数不一样，call 传递参数arg1,arg2...形式 apply 必须数组形式[arg]
3. bind 不会调用函数，可以改变函数内部this指向。

主要应用场景：

1. call 经常做继承
2. apply 经常跟数组有关系，比如借助于数学对象实现数组最大值最小值
3. bind 不调用函数，但是还想改变this指向，比如改变定时器内部的this指向

### 3.8  map 和forEach的区别

相同点：

1. 都是循环遍历数组中的每一项
2. 每次执行匿名函数都支持三个参数，参数分别为item（当前每一项），index（索引值），arr（原数组）
3. 匿名函数中的this都是指向window
4. 只能遍历数组

不同点：

1. map()会分配内存空间存储新数组并返回，forEach()不会返回数据
2. forEach()允许callback更改原始数组的元素

### 3.9  手写数组扁平化（flat）方法

```js
//判断参数是不是数组
//不是则将元素加到新数组里
//是则递归调用函数

const arr = [1,[2,3],[4,[5,[6]],7]];

function func (arry) {
    const newArr = []
    const rec = (arr) => {
        arr.forEach(item => {
            if(!Array.isArray(item)){
            	newArr.push(item)
        	}else {
            	rec(item)
       		}
     	})
    }
    rec(arry)
    return newArr
}
let res = func(arr)
console.log(res)   //[1,2,3,4,5,6]
```

### 3.10  深拷贝与浅拷贝

浅拷贝

Object.assign方法

解构赋值如果是一维数组和对象可以看作深拷贝，多维则是浅拷贝

```js
//深拷贝
let arr = [1,2,3];
let newArr = [...arr];
newArr.push(4);
console.log(arr,newArr);

//浅拷贝
let arr2 = [[1,2,3],[4,5,6]];
let newArr2 = [...arr2];
newArr2 = [...arr2];
newArr2[0].push(888);
console.log(arr2,newArr2)
```

深拷贝：

```js
let list = [
    {id:1,stuName:'小明',class:'五年二班'},
    {id:2,stuName:'小红',class:'五年三班'},
    {id:3,stuName:'小绿',class:'五年四班'},
]
let newList = JSON.parse(JSON.stringify(list));
newList.push({id:4});
console.log(list,newList);

//无法拷贝function
```

```js
//标准的深拷贝  => 引用数据类型（数组，对象）
function deepClone(source) {
    //判断是数组还是对象
    const targetObj = source.constructor === Array ? [] : {}
    for(let keys in source) {
        //如果是引用类型
        if(source.hasOwnProperty(keys)){
            //递归调用
            targetObj[keys] = deepClone(source[keys])
        }else{
            //如果是基本类型，直接赋值
            targetObj[keys] = source[keys]
        }
    }
    return targetObj
}
```

### 3.11 new关键字做了什么

1. 创建空对象

   ```js
   let obj = new Object()
   ```

2. 设置原型链

   ```js
   obj._proto_ = Person.prototype
   ```

3. 改变this指向

   ```js
   let result = Person.call(obj)
   ```

4. 判断返回值类型

   ```js
   if(typeof (result) == "object") {
   	person1 = result
   }else {
   	person1 = obj
   }
   ```

### 3.12 箭头函数和普通函数的区别

1. 不能作为构造函数使用，不能用new关键字
2. 箭头函数没有原型
3. 箭头函数没有arguments
4. 箭头函数不能用call、apply、bind去改变this的指向
5. this指向外层第一个函数的this

### 3.13 说一下事件循环

JS是一个单线程的脚本语言

主线程---->执行栈---->任务队列（微任务---->宏任务）

主线程先执行同步任务（即放在栈里面的内容），然后才去执行任务队列里的任务，如果在执行宏任务之前有微任务，那么要先执行微任务，全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环

### 3.14  Promise的内部原理是什么？它的优缺点是什么？

Promise对象，封装了一个异步操作并且还可以获取成功或失败的结果

Promise主要解决回调地狱的问题，之前如果异步任务比较多，同时他们之间有相互依赖的关系，就只能使用回调函数处理，这样就容易形成回调地狱，代码的可读性差，可维护性也差

有三种状态：pending初始状态----fulfilled成功状态----rejected失败状态

状态改变只会有两种情况：

​				pending---->fulfilled；pending---->rejected；状态只会改变一次

缺点：

无法取消Promise，一旦创建它就会立即执行，不能中途取消

如果不设置回调，promise内部抛出的错误就无法反馈到外面

若当前处于pending状态时，无法得知目前在哪个阶段

原理：

构造一个Promise实例，实例需要传递函数的参数，这个函数有两个形参，分别都是函数类型，一个是resolve一般作为成功时返回的结果，一个是reject一般作为失败时返回的结果

promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数一般作为成功时的回调，reject是执行第二个函数一般作为失败时的回调

### 3.15 Promise和async await的区别是什么？

1. 都是处理异步请求的方式
2. promise是ES6，async await是ES7的语法
3. async await是基于promise实现的，它和promise都是非阻塞性的

优缺点：

1. promise是返回对象，我们要用then，catch方法去处理和捕获异常，并且书写方式是链式，容易造成代码重叠，不好维护，async await是通过try catch进行铺货异常
2. async await最大的有点就是能让代码看起来像同步一样，只要遇到await就会立刻返回结果，然后再执行后面的操作；promise.then()的方式返回，会出现请求还没返回就执行了后面的操作

### 3.16 防抖和节流是什么

都是优化高频执行代码的一种手段

- 防抖：n秒后再执行该事件，若在n秒内被重复触发，则重新计时

  ```js
  function debounce(func,wait) {
      let timeout;
      return function() {
          let context = this;//保存this指向
          let args = arguments;//拿到event对象
          clearTimeout(timeout)
          timeout = setTimeout(function(){
              func.apply(context,args)
          },wait)
      }
  }
  ```

  应用场景：

  1. 搜索框搜索输入，只需用户最后一次输入完，再发送请求
  2. 手机号、邮箱验证输入检测
  3. 窗口大小resize，只需要窗口调整完成后，计算窗口大小，防止重复渲染

- 节流：n秒内只运行一次，若在n秒内重复触发，只有一次生效

  ```js
  function throttled(fn,delay=500) {
      let timer = null
      return function(...args) {
          if(!timer) {
              timer = setTimeout(() => {
                  fn.apply(this.args)
                  timer = null
              },delay)
          }
      }
  }
  ```

  应用场景：

  1. 滚动加载，加载更多或滚到底部监听
  2. 搜索框，搜索联想功能

## 4. Vue

### 4.1 v-if和v-show的区别

都可以控制元素的显示和隐藏

1. v-show时控制元素的display值来让元素显示和隐藏；v-if显示隐藏时把DOM元素整个添加和删除
2. v-if有一个局部编译/卸载的过程，切换这个过程中会适当的销毁和重建内部的事件监听和子组件；v-show只是简单的css切换
3. v-if才是真正的条件渲染；v-show从false变成true时不会触发组件的生命周期，v-if会触发生命周期
4. v-if的切换效率比较低，v-show的效率比较高

### 4.2 如何理解MVVM

是前端开发的架构模式

M：模型，对应的就是data的数据

V：视图，用户界面，DOM

VM：视图模型，Vue的实例对象，连接View和Model的桥梁

核心是提供对View和ViewModel的双向数据绑定，当数据改变的时候，ViewModel能监听到数据的变化，自动更新视图，当用户操作视图的时候，ViewModel也可以监听到视图的变化，然后通知数据进行改动，这就实现了双向数据绑定

ViewModel通过双向绑定把View和Model连接起来，他们之间的同步是自动的，不需要人为干涉，所以我们只需要关注业务逻辑即可，不需要操作DOM，同时也不需要关注数据的状态问题，因为它是由MVVM统一管理

### 4.3 说一下你对vue生命周期的理解

组件从创建到销毁的过程就是它的生命周期

- 创建

  beforeCreate：在这个阶段属性和方法都不能使用

  created：这里是实例创建完成之后，在这里完成了数据检测，可以使用数据，修改数据，不会触发updated，也不会更新视图

- 挂载

  beforeMount：完成了模板的编译，虚拟DOM也创建完成，即将渲染，修改数据，不会触发updated

  mounted：把编译好的模板挂载到页面，这里可以发送异步请求也可以访问DOM节点

- 更新

  beforeUpdate：组件数据更新之前使用，数据是新的，页面上的数据是旧的，组件即将更新，准备渲染，可以改数据

  updated：重新做了渲染，这时数据和页面都是新的，避免在此更新数据

- 销毁

  beforeDestroy：实例销毁前，在这里实例还可以用，可以清除定时器等等

  destroyed：组件已经被销毁了，全部都销毁

- 使用了keep-alive时多出两个周期：

  activited：组件激活时

  deactivited：组件被销毁时

### 4.4 说一说vue中的keep-alive

1. keep-alive时vue的内置组件，能在组件切换过程中将状态保留在内存中，相当于缓存，防止DOM的重复渲染
2. keep-alive有三个属性：include（只有名字匹配的才会被缓存）、exclude（任何名字匹配的都不会被缓存）、max（最多可以缓存进多少个组件）
3. 在路由router中：相应组件下规定meta属性，定义keep-alive：true；

### 4.5 vue列表为什么加key

1. 优化性能，提高虚拟DOM的更新
2. 防止“就地复用问题”（下一个元素复用了上一个在当前位置元素的状态）

### 4.6 vue如何进行组件间通信

1. 父传子

   props：父组件使用自定义属性，子组件使用props接收

   $ref：引用信息回注册在父组件的$refs对象上

2. 子传父

   $emit：子组件绑定自定义事件，触发执行后，传给父组件，父组件需要用事件监听来接收参数

3. 兄弟传

   new一个新的实例，用on和emit来对数据进行传输

4. vuex传值

### 4.7 axios是怎么做封装的

下载--->创建实例--->封装请求响应拦截器--->抛出--->封装接口

```js
//引入axios
import axios from 'axios'
//创建实例
const api = axios.create({
    //请求地址的公共部分
    baseURL:'',
    //请求的超时时间
    timeout:3000
})
//axios拦截器
api.interceptors.request.use(config => {
    //config  请求信息
    return config
},err => {
    //抛出错误
    Promise.reject(err)
})
api.interceptors.request.use(res => {
    console.log(res)
    return Promise.resolve(res)
},err => {
    Promise.reject(err)
})
export default api
```

```js
import api from 'axios.js'
export const login = () api(({
    url:'',
    method:'get',
    params:params
}))
//使用
import {login} from 'request.js'
method: {
    login().then(res => {
        console.log(res)
    })
}
```

### 4.8 vue路由是怎么传参的

- params传参

  ```js
  this.$router.push({name:'index',params:{id:item.id}})
  this.$route.params.id
  ```

- 路由属性传参

  ```js
  this.$router.push({name:'/index/${item.id}'})
  路由配置 {path:'index:id'}
  ```

- query传参（可以解决页面刷新参数丢失的问题）

  ```js
  this.$router.push({
      name:'index',
      query:{id:item.id}
  })
  ```

### 4.9 vue路由的hash模式和history模式有什么区别

1. hash的路由地址上有#号，history模式没有
2. 在做回车刷新的时候hash模式会加载对应页面，history会报错404
3. hash模式支持低版本浏览器，history不支持，因为是H5新增的API
4. hash不会重新加载页面，单页面应用必备
5. history有历史记录，H5新增了pushState和replaceState()去修改历史记录，并不会立刻发送请求
6. history需要后台配置

## 5. 优化

### 5.1  从哪些点做性能优化

- 加载方面
  1. 减少HTTP请求（如精灵图，文件的合并）
  2. 减小文件大小（如资源压缩、图片压缩、代码压缩
  3. SSR服务端渲染，预渲染
  4. 懒加载
  5. 分包
- 减少dom操作，避免回流，文档碎片

## 6. 浏览器

### 6.1  浏览器的渲染机制

浏览器获取页面html文件，解析得到DOM Tree，同时解析CSS文件生成Stylesheet，接着将DOM Tree和Stylesheet结合生成Render Tree，接着进入layout，浏览器通过解析计算出每一个节点的大小和位置，为每一个节点分配屏幕上的确切坐标，最后由GPU进行paint绘制，遍历Render Tree每一个节点，并在屏幕上呈现出来

### 6.2  cookie、sessionStorage、localStorage的区别

三者都是浏览器的本地存储

- cookie是由服务器端写入，生命周期是由服务器端在写入的时候就设置好的，存储空间比较小，大概4KB，（一般用于存储登录验证信息SessionID或者token）,浏览器自动发送
- sessionStorage和localStorage都是由前端写入的，存储空间较大，大概5M，localStorage是写入就一直存在除非手动清除，不能被爬虫 ，sessionStorage是页面关闭的时候就会自动清除；（localStorage常用于存储不易变动的数据，减轻服务器的压力;sessionStorage可以用来检测用户是否刷新进入页面）

三者数据共享都遵循同源原则，但sessionStorage还限制必须是同一个页面。在前端给后端发送请求的时候会自动携带cookie中的数据，但是sessionStorage和localStorage则不会

### 6.3 token的登录流程

1. 客户端用账号密码请求登录
2. 服务端收到请求后，需要去验证账号密码
3. 验证成功之后，服务端会签发一个token，把这个token发送给客户端
4. 客户端收到token后保存起来，可以放在cookie也可以是localstorage
   - 存在cookie中，会自动发送，缺点是不能跨域，会有CSRF攻击
   - 存在localstorage中，后期每次请求接口都需要把它当作一个字段传给后台，容易被XSS攻击
5. 客户端每次向服务端发送请求资源时，都需要携带这个token
6. 服务端收到请求，接着去验证客户端里的token，验证成功了才会返回客户端请求的数据

### 6.4 说一下浏览器的缓存策略

- 强缓存（本地缓存）

  不发起请求，直接使用缓存里的内容，浏览器吧JS，CSS，image等存到内存中，下次用户访问直接从内存中取，提高性能

  触发：

  ​			HTTP1.0：时间戳响应表头

  ​			HTTP1.1： Cache-Control响应表头

- 弱缓存（协商缓存）

  需要向后台发请求，通过判断来决定是否使用协商缓存，如果请求内容没有变化，则返回304，浏览器就用缓存里的内容

  触发：

  ​			HTTP1.0：请求头：if-modified-since 响应头：last-modified

  ​			HTTP1.1：请求头：if-none-match 响应头：Etag

## 7.  Node

### 7.1 



## 8.  网络

### 8.1 说一下什么是同源策略

同源策略是浏览器的核心，如果没有这个策略就会遭受网络攻击

主要指的就是协议+域名+端口号三者一致，其中一个不一样则不是同源，会产生跨域

三个允许跨域加载资源的额标签：img  link  script

跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了
